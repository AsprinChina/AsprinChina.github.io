<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[凸优化问题]]></title>
    <url>%2F2019%2F07%2F20%2Fconvexop%2F</url>
    <content type="text"><![CDATA[​ 在《优化基础理论》博客中，介绍了凸优化问题的定义。这篇博客在此基础上来介绍几种典型的凸优化问题，包括线性规划（Linear Programming，LP）、二次规划（Quadratic Programming，QP）、二次约束二次规划（Quadratically Constrained Quadratic Programming，QCQP）、二阶锥规划（Second-Order Cone Programming）、半定规划（Semidefinite Programming，SDP）。 引言​ 凸优化是优化领域的一个主干方向，这是因为凸优化问题相较其他优化问题有着独到之处，体现在以下几个方面 凸优化问题有着近乎完美的理论，满足很好的数学性质，主要指凸优化问题满足强对偶定理，还有形式便于检验的最优性条件（零梯度点即为全局最优解）。 凸优化问题有着成熟有效的求解算法，这些算法通常都可以在多项式时间内找到全局最优解。一般来说，大多数凸优化问题都可以直接调用商业求解器来完成求解。 凸优化问题有着非常非常多的应用。经济学中的投资优化分配、电力系统中的最优潮流（DC）、机器学习中的支持向量机……都是凸优化问题的一个实例。 ​ 所以对于一个实际问题，在将其抽象成一个数学问题之后，我们首先会检验其是不是凸的，如果不是那么就要使用各种近似、松弛的手段来实现凸化。如果一个问题已经被一个凸优化问题所刻画，那么这个问题通常基本上大概率也就解决了。之所以说这么谨慎就是因为还是有反例的，基本上是大规模问题的求解。比如说经典SVM就是一个典型的QP问题，但是在数据集样本规模极大的情况下，用QP问题的经典算法是难以在合适的时间内算出来的，通常会有相应的算法，比如SVM通常用SMO算法来求解，详情可以参考西瓜书的支持向量机章节。 ​ 凸优化问题的范围极广，只要满足凸优化问题的定义都是。在这些问题中呢，又会有一些更加典型、常见的特殊凸优化问题，这正是接下来要介绍的。 线性规划 (LP)定义​ 只要一个问题的目标函数与约束函数均为仿射函数，则该问题可称为线性规划问题。线性规划问题的一般形式为 \begin{split} &min\ \ &c^Tx+d\\ &s.t. &Ax+b=0\\ &&Gx+h\le 0 \end{split}$c,\ x \in \mathbb R^n,\ d\in\mathbb R,\ A\in\mathbb R^{m_1\times n},\ b\in\mathbb R^{m_1},\ G\in\mathbb R^{m_2\times n},\ h\in\mathbb R^{m_2}$。 ​ 目标函数：仿射函数（点击查看仿射函数与线性函数的定义）。约束条件：仿射函数构成的等式约束与不等式约束。 ​ 线性规划问题有标准形式，定义为 \begin{split} &min\ \ &c^Tx+d\\ &s.t. &Ax+b=0\\ &&x\ge0 \end{split}​ 目标函数：仿射函数。约束条件：【变量的仿射函数构成的等式约束】与【变量的非负约束】。 ​ 解释一下为什么没有不等式约束：任何不等式约束均可通过一个加上一个非负的松弛变量转换为等式约束，如$\{x|x+1\ge0\}$等价于$\{x|x+1=s,\ s\ge0\}$，其中的$s$就称为松弛变量。 ​ 解释一下为什么所有变量均非负：对于任何一个无约束变量$x$，均可将其表示为两个非负变量之差。即$\{x|x \in \mathbb R\}$等价于$\{x|x=x_1-x_2, \ x_1 \in \mathbb R^+, \ x_2 \in \mathbb R^+\}$。 ​ 解释一下为什么有些教材$^{[1]}$会进一步要求式中的$b$为非正数，换句话说要求右手项（将$Ax+b=0$写作$Ax=-b$，其中的$-b$称为右手项）非负：这是因为右手项非负的形式便于推导求解LP的单纯形法。 ​ 任何形式的线性规划问题均可通过一定处理转换为上述标准形式，具体方法参考[1]的2.1节，或者[2]的4.3节。 讨论​ LP问题的可行域是一个凸多面体：每一个仿射约束在$\mathbb R^n$（$n$为优化变量总维数）空间中均构成一个超平面，这些超平面的交集是一个凸多面体。（把等式约束转换成不等式约束的形式，则为超平面划开的半空间的交集，是一个凸多面体，可能更加形象）。 ​ LP问题的目标函数等值线是一个超平面簇：等值线即目标函数具有相同值的点组成的集合，$\{x|c^Tx+d=z\}$是一簇（由$z$确定）正交于向量$c$的超平面。 ​ 上述两点在$\mathbb R^2$空间可用图1$^{[2]}$直观地表示。 图1 LP问题的几何解释 ​ 从上图中可以直观地得到LP问题的一个重要性质：目标函数的最优值一定在可行域的某个极点（通俗说，顶点）上取到。这是单纯形法的基本原理。 解法​ 对于线性规划问题，最常用的算法就是单纯形法。该方法的本质就是从可行域的某个极点出发，依次跳到比当前极点处目标函数值要小的极点，直至某个极点满足最优性条件则终止迭代。 ​ 显然，对于单纯形法，最恶劣的情况是会遍历所有极点的。而$\mathbb R^n$空间中的凸多边形的极点数是随着$n$指数增长的，所以单纯形法是指数时间复杂度的算法。但有趣的是，在实际表现中，单纯形法又很管用，平均时间复杂度表现为多项式时间复杂度。所以单纯形法仍是一种广泛使用的算法。 ​ 单纯形法问世三十余年之后，第一个理论时间复杂度为多项式复杂度的LP问题算法出世，也就是椭球法。但是这个方法的实际性能还不如单纯形法，所以理论意义更大些吧…… ​ 目前的商业求解器对于LP问题用得多的除了单纯形法就是内点法。内点法也是一种多项式时间复杂度的算法，实际表现也不逊于单纯形法，因此得到广泛使用。要指出的是，内点法并不是一种算法，而是一类算法的统称，其基本思想与单纯形法恰恰相反，不是沿着极点跳来跳去，而是穿过可行域内部达到最优点。 ​ 对于LP问题，常用的内点法包括原仿射缩放法（Primal Affine Scaling，自己翻译的，也不晓得准不准确……），Karmarkar法等。各种算法的基本思想一致，不同之处在于如何确定下一步迭代的前进方向与步长，具体不再展开，可以点击上面的链接查看更细致的介绍。 ​ 商业求解器Cplex、gurobi均可对LP问题提供高效的求解支持。 二次规划（QP）定义​ 对于形如 \begin{split} &min\ \ &(1/2)x^TPx+q^Tx+r\\ &s.t. &Ax+b=0\\ &&Gx+h\le 0 \end{split}$P\in\mathbb R^{n\times n},\ q,\ x \in \mathbb R^n,\ r\in\mathbb R,\ A\in\mathbb R^{m_1\times n},\ b\in\mathbb R^{m_1},\ G\in\mathbb R^{m_2\times n},\ h\in\mathbb R^{m_2}$ 的优化问题，若$P$是一个半正定矩阵，则该问题称为二次规划问题。 ​ 目标函数：凸二次函数（敲黑板，不是二次函数，要求凸的）。 ​ 约束条件：仿射函数构成的等式约束、不等式约束。 讨论​ QP问题其实就是把LP问题的目标函数从仿射函数换成了凸二次函数，所以LP问题其实可以看作是QP问题在$P=0$时的一个特例。 ​ 类比LP的几何解释，QP问题的可行域也是一个凸多面体，但是其目标函数等值线不再构成超平面，而是椭球的边界。特别地，$\mathbb R^2$空间内的一般QP问题的目标函数等值线与可行域可用图2$^{[2]}$表示。 ​ 因为目标函数不再是线性的，所以QP问题的最优解无法保证在极点处取到，如图2就是一个例子，这是线性规划与非线性规划的一个重要区别，这也决定了单纯形法仅适用于LP问题。 ​ 非常知名的支持向量机（SVM）模型就是一个典型的QP问题。 图2 QP问题的几何解释 解法​ 对于一个只有等式约束的QP问题，在满足一定假设情况下，通过KKT条件是可以确定其解析解的，无需数值迭代，这一方法称为拉格朗日法。 ​ 但是，QP问题是允许有不等式约束的，这个时候就要扩展出起作用集方法。所谓起作用，就是说不等式取等号成立。e.g.，$x+3\ge0$这个约束，在$x=-3$这个点处，是一个起作用约束；而在$x=0$处则是一个不起作用约束。更直观来说，点在约束函数对应的超平面上就称这个约束起作用。 ​ 而所谓起作用集方法，就是先定一个初始点，确定该点处的起作用约束，然后把起作用约束转成等式约束，并去掉不起作用约束，然后再用拉格朗日法确定解析解。确定解之后，验证起作用的约束情况是否符合假定，若符合则算法结束，否则重新确定起作用约束并继续迭代。 ​ 当然了，QP问题也可以用通用的非线性规划算法来求解，诸如共轭梯度法、内点法等。在内点法中又有路径追踪法是专门针对QP问题而设计的。 ​ 商业求解器Cplex、gurobi均可对QP问题提供高效的求解支持。 二次约束二次规划 (QCQP)定义​ 对于形如 \begin{split} &min\ \ &(1/2)x^TP_0x+q_0^Tx+r_0\\ &s.t. &(1/2)x^TP_ix+q_i^Tx+r_i \le 0,\ \ i=1,2,\cdots,m\\ &&Ax+b=0 \end{split}$P_0,\ P_1,\ \cdots,\ P_m\in\mathbb R^{n\times n},\ q_0,\ q_1,\ \cdots,\ q_m,\ x \in \mathbb R^n,\ r_0,\ r_1,\ \cdots,\ r_m\in\mathbb R,\ A\in\mathbb R^{m_1\times n},\ b\in\mathbb R^{m_1}$ 的优化问题，若$P_0$、$P_i(i=1,2,\cdots,m)$均为半正定矩阵，则称为二次约束二次规划问题。 讨论​ QCQP是在QP问题的基础上，进一步把不等式约束函数从仿射函数推广到了凸二次函数。特别地，当$P_i(i=1,2,\cdots,m)= 0$时，QCQP就变成了一个QP问题。 ​ QCQP问题中非线性约束仅包含二次不等式约束，且要求$P_i$半正定，所以QCQP是一个凸的问题。这决定了QCQP的求解基本上是可以解决的，但对于大规模问题仍然吃力。 ​ 二次不等式约束对应的可行域是$\mathbb R^n$空间中的一个椭球，故QCQP问题的可行域是一个凸多面体与若干椭球的交集。此时，可行域也一般化为非线性情况。 解法​ 因为约束条件也一般化为了非线性情况，所以其解析解难以直接获得，即使是已知所有起作用约束。故QCQP问题的求解一般依赖于通用的非线性优化算法，这其中又以内点法最为推崇。 ​ 商业求解器Cplex、Gurobi均可对QCQP问题提供高效的求解支持。 二阶锥规划 (SOCP)定义​ 对于形如 \begin{split} &min\ \ &p^Tx+q\\ &s.t. &||A_ix+b_i||_2 \le c_i^Tx+d_i \ \ i=1,2,\cdots,m\\ &&Fx+g=0 \end{split}$p,\ x,\ c_i\in\mathbb R^n,\ q,\ d_i\in\mathbb R,\ A_i\in\mathbb R^{m_i\times n},\ b_i\in\mathbb R^{m_i},\ F\in\mathbb R^{k\times n}, g\in\mathbb R^k$ 的优化问题，称为二阶锥规划。 讨论​ 粗粗看，SOCP问题的复杂度比前面难了很多，主要在于其二阶锥约束看起来比较复杂，先说说这里的锥是什么吧。 ​ 锥(Cone)是一类特殊的集合。对于一个集合$C$，若对$\forall x \in C$和$k\ge0$，有$kx \in C$，则称$C$是一个锥。若$C$同时还是一个凸集，则称为凸锥。 ​ 从定义来看，锥是一个无限延申的集合，形状上像个锥子，如图3$^{[3]}$，故取名锥很符合直观感受。 图3 锥 ​ 在众多锥中，有一类由范数定义的锥，称为范数锥。对于$|·|$范数，其范数锥定义为集合 C=\{(x,t)\ |\ \|x\| \le t,\ x\in\mathbb R^n,\ t\in \mathbb R\}​ 相应地，二范数（又称欧几里得范数，其意义为欧式距离）对应的锥称为二阶锥，又称Lorentz锥，其定义为 \begin{split} C&=\{(x,t)|\|x\|_2 \le t,\ x\in\mathbb R^n, \ t\in\mathbb R\}\\ &=\left\{ \begin{bmatrix}x\\t\end{bmatrix} \Bigg| \begin{bmatrix}x\\t\end{bmatrix}^T \begin{bmatrix}&I&0\ \\&0&-1\ \ \end{bmatrix} \begin{bmatrix}x\\t\end{bmatrix} \le 0,\ t\ge0 \right \} \end{split}​ 由此可以看出，SOCP问题中的二阶锥约束构成的可行域正是一个二阶锥，这正是该约束称为二阶锥约束的原因。之所以该问题称为二阶锥规划，将在后面介绍。 ​ 从二阶锥定义的第二行可以看出，二阶锥约束的实质是一个二次不等式约束。当$t=c_i^Tx+d_i$是一个常数，即$c_i=0$时，SOCP问题就变成了一个QCQP问题。这里要注意的是，SOCP的定义中目标函数是仿射函数，而QCQP问题中目标函数允许是凸二次函数，但是这两者是等价的。原因如下。 ​ 目标函数为凸二次函数的标准形式QCQP问题，形如 \begin{split} &min\ \ &(1/2)x^TP_0x+q_0^Tx+r_0\\ &s.t. &(1/2)x^TP_ix+q_i^Tx+r_i \le 0,\ \ i=1,2,\cdots,m\\ &&Ax+b=0 \end{split}​ 可以等价改写为目标函数为仿射函数的QCQP问题，形如 \begin{split} &min\ \ &t\\ &s.t. &(1/2)x^TP_0x+q_0^Tx+r_0 \le t\\ &&(1/2)x^TP_ix+q_i^Tx+r_i \le 0,\ \ i=1,2,\cdots,m\\ &&Ax+b=0 \end{split}​ 而上述形式的问题，正是SOCP问题在$c_i=0$时的特例。 ​ 更特别地，当$A_i=0$时，SOCP问题变成了一个LP问题。 解法​ 同QCQP问题，SOCP问题的求解也依赖通用的非线性优化算法，这其中又以内点法最为常用。 ​ 商业求解器Cplex、gurobi均可对SOCP问题提供高效的求解支持。 半定规划 (SDP)定义​ 对于形如 \begin{split} &min\ \ &c^Tx+d\\ &s.t. &x_1F_1+\cdots+x_nF_n+G\preceq 0\\ &&Ax+b=0 \end{split}$c,\ x\in \mathbb R^n,\ F_1,\ F_2, \ \cdots,\ F_n,\ G\in\mathbb R^{k \times k},\ A\in\mathbb R^{m \times n},\ b \in \mathbb R^m,\ d \in R$ 的优化问题，称为半定规划问题。 讨论​ SDP中的第一个约束是一个矩阵不等式，其左边是一个$k$阶方阵，该不等号指该矩阵半负定。 ​ 当$F_1,\ F_2,\ \cdots,\ F_n,\ G$均为对角矩阵（标量视为对角矩阵的特殊情况）时，SDP问题就是一个LP问题。实际上，SDP问题是一个范围极广的问题，可以由其推导出SOCP的问题形式： ​ 对于形如 \begin{split} &min\ \ &p^Tx+q\\ &s.t. &||A_ix+b_i||_2 \le c_i^Tx+d_i \ \ i=1,2,\cdots,m \end{split}的SOCP问题，可以改写为形如 \begin{split} &min\ \ &p^Tx+q\\ &s.t. & - \begin{bmatrix} &(c_i^Tx+d_i)I &A_ix+b_i\\ &(A_ix+b_i)^T &c_i^Tx+d_i \end{bmatrix} \preceq 0 \ \ i=1,2,\cdots,m \end{split}的SDP问题。 ​ SDP问题范围虽广，但仍属于凸优化范畴，因此有大量相关研究。就应用而言，有许多将一个非凸问题松弛为SDP问题进行求解的实例，比如电力系统中交流最优潮流的SDP松弛。 解法​ 类似QCQP和SOCP，作为更加general的问题，SDP问题也依赖一般化的非线性优化算法，内点法同样又是其中最为常用的算法。 ​ 商业求解器Mosek和SeDuMi可以对SDP问题提供求解支持。 锥规划 (CP)广义不等式​ 在介绍锥规划前，先需要引入广义不等式的概念。而介绍广义不等式之前，又先要补充正常锥的概念。 ​ 对于一个锥$K$，如果$K$满足1、凸的；2、闭的；3、有非空内部（$\mathbf {int} K \neq \varnothing$）；4、集合内不包含直线（即若有$x\in K, \ -x \in K$，则$x=0$），则称$K$是一个正常锥。 ​ 基于正常锥$K$，广义不等式定义为 x\preceq_Ky​ 上式等价于 y-x\in K​ 特别地，当$K=\mathbb R^n_+$（即非负象限）时，【$x\preceq_Ky$】等价于【$x\le y$】。 锥规划定义​ 对于形如 \begin{split} &min\ \ &c^Tx+d\\ &s.t. &Fx+g\preceq_K 0\\ &&Ax+b=0 \end{split}$c,\ x\in \mathbb R^n,\ d\in \mathbb R,\ F\in \mathbb R^{m_1\times n}, g\in\mathbb R^{m_1},\ A\in\mathbb R^{m_2\times n},\ b\in\mathbb R^{m_2}$ 的优化问题，称为锥规划问题。 讨论​ SOCP问题与SDP问题的命名，均可从锥规划角度加以理解。 ​ 对于上述标准形式的SOCP问题 \begin{split} &min\ \ &p^Tx+q\\ &s.t. &||A_ix+b_i||_2 \le c_i^Tx+d_i \ \ i=1,2,\cdots,m\\ &&Fx+g=0 \end{split}​ 可以写成锥规划的形式为 \begin{split} &min\ \ &p^Tx+q\\ &s.t. & -\begin{bmatrix} A_ix+b_i\\ c_i^Tx+d_i \end{bmatrix} \preceq_{K_i} 0 \ \ i=1,2,\cdots,m\\ &&Fx+g=0 \end{split}​ 其中，正常锥$K_i$定义为$\mathbb R^{n+1}$空间中的一个二阶锥： K_i=\left\{ \begin{bmatrix} y\\ t \end{bmatrix} \in \mathbb R^{n+1} \Bigg| \|y\|_2\le t \right\}​ 这正是SOCP问题被称为二阶锥规划的原因，锥规划中$K$为二阶锥的一个特例。 ​ 同样的，SDP问题之所以称为半定规划（或半正定规划），是因为其是锥规划在$K$是半正定矩阵锥（所有半正定矩阵组成的集合）时的一个特例。 各种凸优化问题的关系​ 上文中依次介绍了LP、QP、QCQP、SOCP、SDP、CP问题，是一个从特殊到一般的过程，这些凸优化问题之间的关系可以用图4表示（CO即convex optimization）。 图4 凸优化问题关系 参考资料[1] 陈宝林，最优化理论与算法，清华大学出版社，2005 [2] Boyd S, Vandenberghe L. Convex optimization[M]. Cambridge university press, 2004. [3] Continuous Optimization, Chapter 7: Proper Cones. Peter J.C. Dickinson. DMMP, University of Twente.]]></content>
      <categories>
        <category>优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python环境安装]]></title>
    <url>%2F2019%2F07%2F17%2Fpython%2F</url>
    <content type="text"><![CDATA[​ 过几天要给本科生的一门Python课程当助教，所以在这里介绍一下Python环境的安装。事实上，介绍Python环境安装的教程在网上已经烂大街了，这篇博客力图把安装过程讲清楚，再试图讲讲为什么这么安装，干嘛安装。 ​ 在本篇博客中，安装内容包括 [ ] Anaconda的安装（Python3.7 + Jupyter + Spyder + 常用第三方库） [ ] PyCharm的安装 [ ] MySQL数据库的安装 ​ 点击上述链接即可下载安装包，当然你也可以去官网下载最新版，但是具体安装过程无法保证与接下来的介绍完全一致。 ​ 安装环境是64位的Windows10系统。 Anaconda简介​ Anaconda是Python众多第三方包的管理软件，安装完就自带numpy、pandas等常用的第三方软件包，还配有jupyter和spyder两个常用的开发环境。除此之外，Anaconda还有可视化的Anaconda Navigator工具来管理（下载、删除、更新）第三方的软件包，一键操作省时省心。比如说Tensorflow，不用conda的话可能要装还真是一个麻烦事，毕竟在TF官网上也是推荐了用conda来装。 ​ Anaconda自带很多工具包，所以整个软件比较大，如果很多第三方的包不需要安装，可以选择体量更小的Miniconda。 安装 双击下载下来的Anaconda安装包，弹出设备更改允许选项，点允许。 弹出安装界面，点击next开始。 进入协议界面，选择同意协议。 选择“为本用户安装”，然后点击next。 选择Anaconda的安装路径，然后选择next。推荐默认路径，这样在请别人进行问题排查的时候会方便一些…… 进入高级选项界面，勾选“把Anaconda路径添加到环境变量PATH”。 当某个路径添加到环境变量PATH之后，系统就可以直接运行该路径下的各个文件。举个例子，这里添加conda路径之后，就可以直接在cmd中使用conda指令。 如果安装过程中这一步没有勾选也不要紧，右键“此电脑”，打开”属性“，点开左侧栏最下方的“高级系统设置”，点击右下方的“环境变量”，在弹出的窗口中选择系统变量中的“Path”进行编辑，最后再在弹出的窗口中选择新建，输入conda.exe所在的文件夹路径，并保存，即可。 然后点击install开始安装。等待安装完成后，两次next一次finish完成整个Anaconda的安装过程。 Python​ Anaconda安装完是自带Python的，这个版本的安装包默认自带的是Python3.7版本。在缺省的安装路径”C:\ Users\administrator\Anaconda3“目录下，可以找到python.exe，这个就是python解释器，各种.py文件就是通过这个解释器进行执行的。 ​ 然后还是在上述目录下面，还有一个Scripts文件夹，里面就放了我们安装的各类application，比如jupyter和spyder。完成Anaconda之后，Anaconda目录和Scripts目录是自动添加到环境变量PATH中的，这样我们才可以在cmd中直接运行这些application。 ​ 你可以打开一个cmd窗口，然后输入python并回车，就会发现进入了python环境，exit()指令退出python环境，再输入spyder指令即可弹出spyder应用界面。如果你在环境变量PATH中删除这些路径，重新开一个cmd并敲入python，spyder等指令就会报错。 ​ 然后在python所在的根目录下（在这里，也就是Anaconda文件夹），还有一个Lib文件夹，里面还有一个site-packages文件夹，在这个文件夹里面存放了我们所有下载下来的第三方软件包，如果是Anaconda安装的Python，那么在这个文件夹里面就已经有了”pandas“、”numpy”等文件夹，这些文件夹里面都有一个__init__.py文件，所以是一个packge（包）。更细致的介绍可以参考这个。 Anaconda Navigator​ Anaconda Navigator是一个Anaconda管理conda环境、第三方软件包的可视化界面。安装Anaconda后可以在【开始】菜单左侧最上方的“最近添加”栏处找到，点击打开如图。 ​ 左侧菜单有4个选项，主要常用的就是前两个。 ​ “主页”中提供了各类应用，如常见的jupyter和spyder开发环境，关于这两个开发环境后面再展开介绍。 ​ “环境”中又有两栏，第一栏是Anaconda中已创建的环境，缺省是root环境，我们可以通过conda命令创建新的环境（详情点击链接，不展开）。对于新的环境，说穿了就是一个新的python文件夹，通常在安装tensorflow的时候我们就会创建一个新的环境。第二栏是当前环境下，python已经安装的库，当然，你也可以在这一栏中搜索没有安装的库并安装。 ​ ”学习“中是各类教程、使用手册等，涵盖面广。 ​ ”社区“中则是各类主题网络社区的链接。 第三方库的安装​ Python的强大，并不是说他的语法有多么多么精妙，而是说Python有很多很多功能强大的第三方库，涉及到各类应用的方方面面，图像处理有pillow、opencv，机器学习有sklearn、tensorflow、keras，科学计算有numpy、scipy等等。 ​ 尽管安装Anaconda的时候已经自带了很多常用的第三方库，但是很多时候这些库并不能完全cover我们的需求，这个时候我们就要自行安装第三方库，这里介绍三种常用的方法。 第一个办法就是上面提到的，在Anaconda Navigator中选择一个环境，然后搜索这个库，选择install即可。 第二个办法是用conda工具，打开一个cmd窗口，然后输入conda install ***（库名），比如安装pandas就是敲入conda install pandas。 第三个办法是使用Python自带的pip工具，也是打开一个cmd窗口，然后输入pip install ***即可。 ​ 对大多数包来说，三种方法都行得通，只有像tensorflow这样的，一般就用第一种方法。 ​ 看了一下课程大纲，要完成这门课要求的话，大家至少得安装以下这些第三方软件包：pillow、opencv-python、pandas、numpy、smtp、email、imaplib、tensorflow、requests、beautifulsoup4、flask、flask_wtf、wtforms。请大家先自行用上述方法安装吧。 Jupyter Notebook​ Jupyter是一个基于web的交互式Python环境。关键词有两个：基于web，交互式。 ​ 基于web是说整个jupyter的界面是在浏览器中实现的，如图。 ​ 交互式是说程序可以局部运行，实时看到执行结果等，是较好的人机体验吧。 ​ jupyter可以在cmd中键入jupyter打开，也可以在Anaconda Navigator的主界面打开。 ​ 小彩蛋：jupyter（Julia+Python+R，三种语言）与jupiter同音，据维基百科说是为了纪念伽利略记录发现木星的卫星的笔记本。 Spyder​ Spyder是一个清爽好用的IDE（集成开发环境），整个默认界面有三部分，和Matlab几乎一模一样……我刚学Python时用的IDE还是PyCharm（后面会介绍、安装），不过由于对Matlab的工作区和命令行念念不忘，实在好用……所以后来还是改用Spyder了。 ​ 默认界面如图，左边一大块代码窗，编辑.py文件（其实也支持其他文件的编辑，就是不能运行罢了），左下角是命令行，熟悉matlab的都懂……就不多说了。然后这两个区域的代码生成的各种变量都保存在工作区，支持双击查看、编辑、保存、删除等操作。 ​ 整体直观方便，如果你熟悉matlab，spyder会是一个很好的IDE选择。 PyCharm简介​ 第二个要安装的软件是PyCharm，也是一个IDE软件。和上述spyder的区别在于这个IDE颜值比较高功能比较丰富。但功能强大带来的一个很直接的问题就是使用起来比较麻烦。 ​ 这是PyCharm的默认界面，确实好看，首先看到的就是一个文件导航、代码窗和打印输出的控制台，没有命令行也没有工作区，看起来好像少了很多功能，但实际上只是PyCharm把他们都藏了起来。 ​ 实际上，PyCharm作为使用最为广泛的Python专用IDE，有很多附加功能，spyder有的工作区、命令行都可以设置（但工作区的实际体验确实不如Spyder）。除此之外，PyCharm的代码编辑功能比Spyder丰富很多，Spyder很大一个槽点就是不支持代码折叠……9012年了还不支持代码折叠也就仅此一家了吧。另外，PyCharm的控制台还集成了Python Console、cmd窗口（terminal）等功能。PyCharm还支持Python第三方包的管理，但在实际使用体验上很多包会安装失败，所以还是用Anaconda来装吧。还有，PyCharm还支持Jupyter交互格式，能打开Jupyter文件并使用……总之，PyCharm功能极为丰富，具体怎么用就留待同学们自己去探索了。 安装​ PyCharm有community和professional两个版本，区别在于前者免费，我们使用前者的功能足矣。 双击运行PyCharm安装包，如果弹出设备更改允许选项，点允许。 弹出PyCharm安装界面，点击next开始安装。 选择安装路径，推荐默认，原因同上。选择完毕点击next开始下一步。 勾选“add launchers dir to the PATH”，将PyCharm路径加入到环境变量PATH中，其余三个随意。 默认名称，点击install开始安装。等待安装完成。 进度条满了之后，点击finish完成安装。可以选择重启更新系统变量。 MySQL简介​ 课程大纲中有涉及到数据库操作的内容，所以我们需要预装一个数据库软件。数据库主要有关系型（SQL）和非关系型（noSQL）两类。P.S. noSQL全称是not only SQL，你说翻译的人当时咋想的给译成了非关系型……然后我们这里使用SQL数据库进行实例介绍，然后具体产品选用了开源免费的MySQL数据库（社区版）。 ​ MySQL作为一种SQL数据库，其特点就是数据按表存储，每行表示一条记录，列名加若干记录组成一张表，若干表又组成一个数据库。我们安装MySQL的实质就是在本地创建一个服务器来存储MySQL数据，以便后续通过一定的方式（命令行/可视化前端）来访问这个服务器以读写其中的数据。 安装 双击运行mysql-installer-community-8.0.16.0.msi，若弹出设备更改选项，点允许。 进入”License Agreement“界面，首先勾选“同意协议”，然后点击next进入下一个页面。 进入“Choosing a Setup Type”界面，选择默认选项Developer Default，然后点击next。 在这个界面会确认安装依赖。有些MySQL产品会依赖一些外部文件/程序才能正常运行，这个时候我们就要先安装被依赖的程序才能继续安装MySQL产品。 这里的话主要是MySQL Sever和MySQL WorkBench两个产品需要依赖Visual C++ Redistributable for Visual Studio 2015，可以点击链接进行下载安装 ，选择其中的x64版本。下载下来之后双击安装即可，然后重启MySQL的安装包。 确认依赖文件安装完成之后点击next进入下一个界面。可能会提示还需要别的依赖文件，但是我们这里暂时用不到，所以直接点确定就行，MySQL会自动取消这些产品的安装。 进入“Installation”界面，确认以下产品会被安装（Server、Workbench、Shell），点击execute，等待所有产品安装完毕。 进入“Product Configuration”界面，默认情况下，会有3个产品需要配置。 点击next开始服务器配置（产品1/3），会进入到一个新的界面。 第一个界面（high availability）：选择MySQL服务器（默认选项），点击next。 第二个界面（type and networking）：协议与网络设置，保持默认配置，直接点next。默认配置如图。 第三个界面（authentication method）：选择使用强密码（默认选项），这个是以后建立MySQL服务器链接的依据，然后点击next。 第四个界面（accounts and roles）：输入你的密码并确认，然后点击next。 第五个界面（windows service）：配置Windows服务，保持默认配置即可，直接点击next。配置如图。 点击execute执行上述配置。等待配置完成，然后点击finish。 回到原来的界面，点击next开始路由配置（产品2/3）。也会进入到一个新界面。 保持默认选项，直接点next完成配置。 回到原来的界面，点击next开始样例设置（产品3/3）。也会进入到一个新界面。 在弹出的界面中输入刚刚设置的密码，然后点击check检测密码是否正确，正确情况下点击next。 在这个界面中点击execute，安装程序会自动在本地的MySQL服务器创建相应的数据库样例。 完成后，点击finish结束样例安装。 至此产品安装就结束了。需要注意的是，此步的安装内容与顺序会因安装的MySQL产品不同而不同。 进入“Installation Complete”界面，安装完成。完成后可能弹出workbench和shell的界面，分别是mysql数据库的图形化界面与命令行界面，暂时不用的话关闭即可。 装完软件之后，可以用MySQL的可视化软件创建一个数据库验证一下。 在Windows开始菜单找到新安装的MySQL Workbench 8.0 CE，并打开。 在界面左侧的MySQL Connections找到Local Instance MySQL80，打开。第一次打开会要求输入密码，输入并点击记住密码即可。 查看已有的数据库：在左侧的导航栏有一个sys数据库（logo像桶），然后里面有tables（logo是3张表）记录了这个数据库里面的所有表，展开之后里面是一张sys_config表，右键Table Inspector可以查看这张表的信息，包括列名、记录行数等信息。 新建一个数据库：界面上方的菜单栏中有一个长得像桶的logo，点击新建一个数据库（输入相关信息后点击apply）。 新建一张数据表：界面左侧的导航栏中展开新建的数据库，在tables处右键选择新建数据表（输入相关信息后点击apply）。 更多操作我们将在后续课程中用python与SQL语句来完成，Workbench的意义还是在于可视化数据库。]]></content>
      <categories>
        <category>生产工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优化基础理论]]></title>
    <url>%2F2019%2F07%2F07%2Foptimizationbase%2F</url>
    <content type="text"><![CDATA[引言​ 小站里面后续很多内容都是围绕着优化展开的，所以第一篇博客自然就要讲一讲优化的基础内容。有两方面目的，一是介绍一些数学基础，省去后续赘述；二是规定一下标准形式，这会影响到后续一些结论的形式，本站均采用Boyd的《Convex Optimization》中的标准形式。 ​ 一般地，一个优化问题可以写为目标函数+约束（进一步区分为等式约束与不等式约束）的格式，本站中规定其标准形式为： \begin{split} &min\ \ &f(x)\\ &s.t. &g(x)\ge0\\ &&h(x)=0 \end{split}​ 再规定上述优化问题的拉格朗日函数为 L(x,\mu,\lambda)=f(x)+\mu ^T g(x)+\lambda ^T h(x)​ 上述形式和一些优化教材中的并不一致，比如陈宝林老师的《最优化》，其乘子定义是上述形式的相反数。之所以在各种形式中选取Boyd书中的这一种，是因为大多数文献中均采用这一格式，且诸多优化求解器如cplex、gurobi中的乘子定义也采用这一格式。 基本概念梯度，雅可比矩阵，与海森矩阵​ 定义向量$x=[x_1,\ x_2,\ \cdots,\ x_n]^T$，标量函数$f(x)$，与向量函数$F(x)=[f_1(x),\ f_2(x),\ \cdots,\ f_m(x)]^T$ 则$f(x)$的梯度定义为 \nabla f(x)=[\frac{\partial f(x)}{\partial x_1},\ \frac{\partial f(x)}{\partial x_2}, \ \cdots,\ \frac{\partial f(x)}{\partial x_n}]^T$f(x)$的海森矩阵定义为 \nabla ^2 f(x) = \begin{bmatrix} \frac{\partial ^2 f(x)}{\partial x_1^2} & \frac{\partial ^2 f(x)}{\partial x_1 \partial x_2} & \cdots & \frac{\partial ^2 f(x)}{\partial x_1 \partial x_n} \\ \frac{\partial ^2 f(x)}{\partial x_2 \partial x_1} & \frac{\partial ^2 f(x)}{\partial x_2 ^2} & \cdots & \frac{\partial ^2 f(x)}{\partial x_2 \partial x_n} \\ \vdots & \vdots & \ddots & \vdots \\ \frac{\partial ^2 f(x)}{\partial x_n \partial x_1} & \frac{\partial ^2 f(x)}{\partial x_n \partial x_2} & \cdots & \frac{\partial ^2 f(x)}{\partial x_n^2} \\ \end{bmatrix}$F(x)$的雅可比矩阵定义为 Jacobi(F)= \begin{bmatrix} \frac{\partial f_1(x)}{\partial x_1} & \frac{\partial f_1(x)}{\partial x_2} & \cdots & \frac{\partial f_1(x)}{\partial x_n} \\ \frac{\partial f_2(x)}{\partial x_1} & \frac{\partial f_2(x)}{\partial x_2} & \cdots & \frac{\partial f_2(x)}{\partial x_n} \\ \vdots & \vdots & \ddots & \vdots \\ \frac{\partial f_m(x)}{\partial x_1} & \frac{\partial f_m(x)}{\partial x_2} & \cdots & \frac{\partial f_m(x)}{\partial x_n} \end{bmatrix}​ 从上述定义中可以看到，$f(x)$的梯度的雅可比矩阵就是其海森矩阵。 凸集​ 记$S\in\mathbb R^n$，若对$\forall x_1,\ x_2\in S, \ \forall \lambda \in [0,1]$有 \lambda x_1 + (1-\lambda)x_2 \in S则称$S$是一个凸集。 ​ 感性来说，在一个集合里面任选两点连起来，如果这条线段被这个集合包围，则为凸集，反之就不是，如图1$^{[1]}$。 图1 左：凸集，右：非凸集 凸函数​ 对于函数$f(x)$，若满足定义域为非空凸集，且对$\forall x_1,\ x_2\in \mathbf {dom} \ f, \ \forall \lambda \in [0,1]$有 f(\lambda x_1+(1-\lambda) x_2) \le \lambda f(x_1)+(1-\lambda)f(x_2)则称$f(x)$是定义域上的凸函数，$-f(x)$是定义域上的凹函数。 ​ 感性来说，一个函数上任意两点连线，这条线段比原函数不低，则为凸函数，反之则不是，如图2$^{[1]}$。 图2 凸函数 ​ 特别地，如果$f(x)$可微，那么可用更方便的一阶条件（要求一阶可微）、二阶条件（要求二阶可微）判断凸函数。 ​ 一阶条件：定义在非空开凸集上的可微函数$f(x)$是凸函数的充要条件是，对$\forall x_1,\ x_2\in \mathbf {dom} f\ $有 f(x_2) \ge f(x_1)+\nabla f(x_1)^T(x_2-x_1)​ 二阶条件：定义在非空开凸集的二次可微函数$f(x)$是凸函数的充要条件是，对$\forall x \in \mathbf {dom} f\ $有$\nabla ^2 f(x)$半 正定。 凸优化问题​ 若一个优化问题是求凸函数在凸集上的极小点，则称为凸优化问题。 ​ 对于引言中所述的优化问题标准形式，若满足$f(x)$是凸函数，$g(x)$是凹函数，$h(x)$是仿射函数，则该优化问题是一个凸优化问题。 ​ 此处要特别注意，优化问题中的约束必须是剔除冗余约束的。举个例子，对于问题 \begin{split} &min\ \ &y\\ &s.t. &y^2-1\ge0\\ &&y\ge0 \end{split}看似$g(y)=y^2-1$的海森矩阵正定，是一个凸函数，故上面这个问题非凸，但实际上从定义出发可推得两个约束构成的可行域是一个凸集，故该问题是一个凸优化问题。之所以产生这样的矛盾是因为上述表达中未剔除冗余约束，把$\{y|y^2-1\ge0\}$改写成$\{y|y\ge1\} \cup \{y|y\le-1\}$，而该集合与另一个约束构成的可行域$\{y|y\ge0\}$的交集为$\{y|y\ge1\}$，即上述问题中$y\le-1$和$y\ge0$均为冗余约束，故原问题等价于 \begin{split} &min\ \ &y\\ &s.t. &y\ge1 \end{split}这显然是一个凸问题，既满足凸问题的原始定义，也符合标准形式判据。 凸优化问题有诸多良好的性质，比如局部最优解就是全局最优解等，通常可以被商业求解器(gurobi、cplex)很好解决，故一个优化问题是不是凸的通常被视为一个问题好不好求解的分水岭。 凸优化问题又可以按照目标函数与约束的函数特点进一步细分为线性规划（LP）、二次规划（QP）、二次约束二次规划（QCQP）、二阶锥规划（SOCP）、以及半正定规划（SDP），后续将会专门出一个blog来介绍这些特殊的凸优化问题。 共轭函数​ 共轭函数又称勒让德变换。记$f(x)$是一个从$\mathbb R^n$到$\mathbb R$的映射，其共轭函数（也是一个从$\mathbb R^n$到$\mathbb R$的映射）定义为 f^*(y)=\mathop{sup}\limits_{x \in \mathbf {dom} \ f} \ (y^Tx - f(x))​ 图3$^{[1]}$是$\mathbb R$空间中一个函数$f(x)$在某个$\hat y$取值处的共轭函数值示意：对一个确定的$\hat y$，以之为斜率作一过原点的直线，记在$\hat x$处有$f’(\hat x)=\hat y$（图中切点），那么$f^*(\hat y)= \hat y ^T \hat x - f(\hat x)$，正是图中$f(x)$切线的截距相反数。 ​ 特别地，当$\hat y=0$时，$f^*(0)$就是$f(x)$下界的相反数。 图3 共轭函数 ​ 共轭函数的一个重要性质是，其是关于$y$的一个仿射函数，是凸的。共轭函数在对偶问题的表示上有重要作用，尤其是线性约束的优化问题（$y$视为对偶变量）。 最优性条件​ 对于一个优化问题，若要找到其最优解，首先就要明确最优解有什么性质，满足什么条件，然后才能够据此去推导求解的算法。最优解满足的条件（必要、充分、充要）称为最优性条件。 ​ 本节仅介绍各种问题的最优性条件，其中的推导与证明可在[1]、[2]中找到。 ​ 在邻域内目标函数值最小的解称为局部最优解（极小点），在整个定义域内目标函数值最小的解称为全局最优解（极小点）。 无约束问题的最优性条件​ 对于可行域是全空间的无约束优化问题 min\ \ f(x)一阶必要条件​ $f(x)$在$\hat x$处可微，若$\hat x$是局部极小点，则$\nabla f(\hat x)=0$。 ​ 这是一个必要条件而非充分条件。一般地，满足$\nabla f(x)=0$的点称为$f(x)$的驻点，如果驻点邻域内的函数值均比驻点函数值大，则该驻点称为极小点；如果驻点领域内函数值均比驻点函数值小，则该驻点称为极大点；两者均不满足则称为鞍点，如图4。 图4 驻点：极小点、极大点与驻点 二阶必要条件​ $f(x)$在$\hat x$处二次可微，若$\hat x$是局部极小点，则$\nabla f(\hat x)=0$，且$\nabla ^2 f(\hat x)$半正定。 ​ 相比一阶必要条件，二阶必要条件多的“海森矩阵“就是用来判断驻点类型的。一般地，对于极大点，海森矩阵半负定；对于极小点，海森矩阵半正定；对于鞍点，海森矩阵不定。 二阶充分条件​ $f(x)$在$\hat x$处二次可微，若$\nabla f(\hat x)=0$，且$\nabla ^2 f(\hat x)$正定，则$\hat x$是局部极小点。 充要条件​ $f(x)$是可微凸函数，则$\hat x$是局部极小点（也是全局最优解）的充要条件是$\nabla f(\hat x)=0$。 ​ 嗯，凸优化问题的良好求解性质可见一斑。 有约束问题的最优性条件​ 对于有约束优化问题（这里不妨都假设$f(x),\ g(x),\ h(x)$均可微） \begin{split} &min\ \ &f(x)\\ &s.t. &g(x)\ge0\\ &&h(x)=0 \end{split}​ 定义广义拉格朗日函数 L(x,\mu,\lambda)=f(x)+\mu ^T g(x)+\lambda ^T h(x)其中$\mu, \ \lambda$称为约束的拉格朗日乘子，其物理意义是约束的右手项（式中为0的那个常数项）变动一个单位对目标函数最优值的影响。 ​ 乘子在很多领域都有直接的应用，在经济学中资源约束的乘子又称为资源的影子价格，在电力市场中有功平衡约束的乘子又称为节点电价。 一阶必要条件（KKT条件）​ 对于上述优化问题，如果$\hat x$是其局部最优解，且$\nabla g(\hat x), \ \nabla h(\hat x)$线性无关，那么必然存在$\hat \mu, \ \hat \lambda$使得 \left \{ \begin{array} \\ & \nabla_xL(\hat x,\ \hat \mu,\ \hat \lambda)=0 &(1) \\ & g(\hat x)\ge0 &(2) \\ & h(\hat x)=0 &(3) \\ & \hat \mu _i g_i(\hat x)=0 &(4) \\ & \hat \mu \ge 0 &(5) \\ \end{array} \right.​ 上式又称为KKT条件，其中： ​ （1）式可以直观地理解为无约束优化问题一阶必要条件的推广，即，将有约束问题的约束通过拉格朗日松弛罚到目标函数中，转成一个无约束问题，再使用无约束优化的一阶必要条件，就是（1）式。 ​ （2）式和（3）式是原问题约束，保证了解的可行性。 ​ （4）式称为互补松弛约束，即每个不等式约束的函数值和其乘子之积择一非零，下标$i$表示约束向量和乘子向量中的各个分量。写成矩阵形式即两个向量正交：$\hat \mu \bot g(\hat x)$。互补松弛约束的物理意义是说，对于每一个不起作用约束（那些函数值大于0而不是等于0的约束）其乘子一定为零。套用影子价格的物理概念，这是很直观的一件事情：如果某项资源在达到最优解时仍有剩余，那么再增加或减少这项资源一个$\epsilon$（无穷小量），并不会引起最优利润的改变，所以影子价格为0，也就是乘子为0。 ​ （5）式是推导过程中的中间条件（用于Gordan定理的应用）。 一阶充分条件​ 特别地，如果该优化问题是一个凸优化问题，那么KKT条件也是“$\hat x$是局部（或全局）最优解”的充分条件。 二阶条件​ 无约束优化的二阶条件也可以推广到有约束优化，即从目标函数的海森矩阵推广到拉格朗日函数的海森矩阵，但会增加一些复杂的规格约束。实际使用中感觉一阶条件更为常用，二阶条件使用较少，在Boyd的书中我也没找到相关论述，感兴趣的同学可以参考陈宝林老师的《最优化》$^{[2]}$中7.2.5节。 对偶问题​ 对偶问题有着强烈的物理意义，在很多算法中都有巧妙的应用，所以在这里也介绍经常用到的一些基本概念。 原问题与对偶问题​ 对于优化问题（称为原问题） \begin{split} & \mathop{min} \limits_x \ &f(x) \\ &s.t. &g(x)\ge0 \\ &&h(x)=0 \\ &&x \in D \end{split}其中集合$D$称为原变量$x$的集约束。集约束可以任意选取，比如选为$\mathbb R ^n$，在比如把$g(x),\ h(x)$全部放进来，均不影响最终求得的对偶问题的一致性，但是会影响计算对偶问题目标函数（又称为拉格朗日对偶函数）的工作量。 ​ 上述原问题对应的对偶问题为 \begin{split} &\mathop{max}\limits_{\mu,\ \lambda} \ &\mathop{inf}\limits_{x \in D} \ L(x,\mu, \lambda) \\ &s.t. &\mu \ge0 \\ \end{split}​ 对偶问题具有互逆性，即对偶问题的对偶问题是原问题。 对偶定理弱对偶定理​ 原问题目标函数值总是大于等于对偶问题目标函数值，即 f(x)\ge\mathop{inf}\limits_{x \in D} \ L(x,\mu, \lambda)\ \ \ \ \ \forall x,\ \mu,\ \lambda​ 原问题目标函数下界与对偶问题目标函数上界之差称为对偶间隙，即$\mathop{inf}\limits_{x}\ f(x)-\mathop{sup}\limits_{\mu,\ \lambda}\ \mathop{inf}\limits_{x \in D} \ L(x,\mu, \lambda)$。 强对偶定理​ 若原问题是一个凸优化问题，且满足slater约束规格，则原问题目标函数下界与对偶问题目标函数上界之差为0，即不存在对偶间隙。 ​ 可见凸优化问题的又一良好求解性质，此时可以通过求对偶问题上界来求原问题最小值，这是在很多算法中经常使用的手段。 鞍点定理 若$\hat x, \ \hat \mu,\ \hat \lambda$满足 L(\hat x,\ \mu,\ \lambda)\le L(\hat x, \ \hat \mu, \ \hat\lambda)\le L(x, \ \hat \mu, \ \hat\lambda)​ 则称$(\hat x, \ \hat \mu, \ \hat\lambda)$是拉格朗日函数的鞍点。 若$(\hat x, \ \hat \mu, \ \hat\lambda)$是拉格朗日函数的鞍点，则$\hat x$和$(\hat \mu,\ \hat \lambda)$分别是原问题和对偶问题的最优解。 若原问题是凸优化问题，且满足slater约束规格，且存在最优解$\hat x$，那么存在$\hat \mu (&gt;0), \ \hat \lambda$使得$(\hat x, \ \hat \mu, \ \hat\lambda)$是拉格朗日函数的鞍点。 优化问题的求解算法​ 在分析了最优性条件之后，就是要利用这些性质去推导求解优化问题的算法。 ​ 按照求解算法是否利用目标函数的导数信息，优化问题的求解算法可以分为使用导数的优化方法和不使用导数的直接方法两大类。按照求解的优化问题有没有约束，优化问题的求解算法又可以分为无约束问题的优化方法和有约束问题的优化方法。 ​ 这一部分内容比较多，后续将会专门开一个blog来介绍各种优化算法的原理推导、工作特性以及代码实现等。 参考资料[1] Boyd S, Vandenberghe L. Convex optimization[M]. Cambridge university press, 2004. [2] 陈宝林，最优化理论与算法，清华大学出版社，2005]]></content>
      <categories>
        <category>优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客编辑与发布]]></title>
    <url>%2F2019%2F07%2F07%2Fblog-edit-deploy%2F</url>
    <content type="text"><![CDATA[​ 最近开始写一些技术博客，一来是强化自己的记忆与理解，二来也是分享自己的看法，感恩自己看过的一些技术博客。本站采用hexo框架搭建，每个技术博客都采用markdown语法完成（不是写QQ空间日志那样的……）。这里介绍一下markdown语法的基本规则，以及在hexo框架中如何发布完成的博客。 markdown规则——怎么写blog标题1个# 到 6个# 分别表示一级标题（large）到六级标题（small)。#号与文字之间留一空 列表无序列表前面加* 1 (* 1) 2 (* 2) 有序列表前面加数字 1 (1. 1) 2 (2. 2) 引用 文字前面加&gt; (&gt; 123) 插入图片 上一行代码为 ! [图片名] (图片地址/链接) 超链接这是GitHub的网站链接。 上一行代码为 这是[GitHub] (http://github.com)的网站链接 粗体与斜体这几个字是粗体，用两个星号包围 这几个字是斜体，用一个星号包围 上一行代码为 **……** *……* 用’\\’进行转义 代码框12import numpy as npimport tensorflow as tf 格式为``` codes ``` 更多规则公式、脚注、删除线、上下标、任务列表、高亮等，点击链接 博客推送规则——怎么传blog 前序工作：github申请一个page，本地安装git、nodes、hexo等，完成个性化设置……详情点击 常用指令： hexo clean：清除部署网站的缓存 hexo g：generate，在本地生成静态网页文件 hexo d：deploy，将本地静态文件部署到github hexo s：sever，将本地静态文件部署到本地端口（localhost:4000） hexo new blogname：新建一个名为blogname的博客 hexo new page pagename：新建一个名为pagename的子网页 blog推送 在hexo安装文件夹处打开git窗口（git bash here）。 hexo命令新建一个博客：hexo new newblog，然后会在hexo文件夹下的/source/_posts文件夹里面生成相应名字的md文件（newblog.md）。 在这个md文件中写入博客内容（markdown格式）。 git窗口中依次输入指令hexo clean清除缓存，输入指令hexo g在本地生成静态文件，输入指令hexo d部署到github中。 完成blog发布。]]></content>
      <categories>
        <category>生产工具</category>
      </categories>
  </entry>
</search>
