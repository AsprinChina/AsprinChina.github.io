<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python环境安装]]></title>
    <url>%2F2019%2F07%2F17%2Fpython%2F</url>
    <content type="text"><![CDATA[​ 过几天要给本科生的一门Python课程当助教，所以在这里介绍一下Python环境的安装。事实上，介绍Python环境安装的教程在网上已经烂大街了，这篇博客力图把安装过程讲清楚，再试图讲讲为什么这么安装，干嘛安装。 ​ 在本篇博客中，安装内容包括 [ ] Anaconda的安装（Python3.7 + Jupyter + Spyder + 常用第三方库） [ ] PyCharm的安装 [ ] MySQL数据库的安装 ​ 点击上述链接即可下载安装包，当然你也可以去官网下载最新版，但是具体安装过程无法保证与接下来的介绍完全一致。 ​ 安装环境是64位的Windows10系统。 Anaconda简介​ Anaconda是Python众多第三方包的管理软件，安装完就自带numpy、pandas等常用的第三方软件包，还配有jupyter和spyder两个常用的开发环境。除此之外，Anaconda还有可视化的Anaconda Navigator工具来管理（下载、删除、更新）第三方的软件包，一键操作省时省心。比如说Tensorflow，不用conda的话可能要装还真是一个麻烦事，毕竟在TF官网上也是推荐了用conda来装。 ​ Anaconda自带很多工具包，所以整个软件比较大，如果很多第三方的包不需要安装，可以选择体量更小的Miniconda。 安装 双击下载下来的Anaconda安装包，弹出设备更改允许选项，点允许。 弹出安装界面，点击next开始。 进入协议界面，选择同意协议。 选择“为本用户安装”，然后点击next。 选择Anaconda的安装路径，然后选择next。推荐默认路径，这样在请别人进行问题排查的时候会方便一些…… 进入高级选项界面，勾选“把Anaconda路径添加到环境变量PATH”。 当某个路径添加到环境变量PATH之后，系统就可以直接运行该路径下的各个文件。举个例子，这里添加conda路径之后，就可以直接在cmd中使用conda指令。 如果安装过程中这一步没有勾选也不要紧，右键“此电脑”，打开”属性“，点开左侧栏最下方的“高级系统设置”，点击右下方的“环境变量”，在弹出的窗口中选择系统变量中的“Path”进行编辑，最后再在弹出的窗口中选择新建，输入conda.exe所在的文件夹路径，并保存，即可。 然后点击install开始安装。等待安装完成后，两次next一次finish完成整个Anaconda的安装过程。 Python​ Anaconda安装完是自带Python的，这个版本的安装包默认自带的是Python3.7版本。在缺省的安装路径”C:\ Users\administrator\Anaconda3“目录下，可以找到python.exe，这个就是python解释器，各种.py文件就是通过这个解释器进行执行的。 ​ 然后还是在上述目录下面，还有一个Scripts文件夹，里面就放了我们安装的各类application，比如jupyter和spyder。完成Anaconda之后，Anaconda目录和Scripts目录是自动添加到环境变量PATH中的，这样我们才可以在cmd中直接运行这些application。 ​ 你可以打开一个cmd窗口，然后输入python并回车，就会发现进入了python环境，exit()指令退出python环境，再输入spyder指令即可弹出spyder应用界面。如果你在环境变量PATH中删除这些路径，重新开一个cmd并敲入python，spyder等指令就会报错。 ​ 然后在python所在的根目录下（在这里，也就是Anaconda文件夹），还有一个Lib文件夹，里面还有一个site-packages文件夹，在这个文件夹里面存放了我们所有下载下来的第三方软件包，如果是Anaconda安装的Python，那么在这个文件夹里面就已经有了”pandas“、”numpy”等文件夹，这些文件夹里面都有一个__init__.py文件，所以是一个packge（包）。更细致的介绍可以参考这个。 Anaconda Navigator​ Anaconda Navigator是一个Anaconda管理conda环境、第三方软件包的可视化界面。安装Anaconda后可以在【开始】菜单左侧最上方的“最近添加”栏处找到，点击打开如图。 ​ 左侧菜单有4个选项，主要常用的就是前两个。 ​ “主页”中提供了各类应用，如常见的jupyter和spyder开发环境，关于这两个开发环境后面再展开介绍。 ​ “环境”中又有两栏，第一栏是Anaconda中已创建的环境，缺省是root环境，我们可以通过conda命令创建新的环境（详情点击链接，不展开）。对于新的环境，说穿了就是一个新的python文件夹，通常在安装tensorflow的时候我们就会创建一个新的环境。第二栏是当前环境下，python已经安装的库，当然，你也可以在这一栏中搜索没有安装的库并安装。 ​ ”学习“中是各类教程、使用手册等，涵盖面广。 ​ ”社区“中则是各类主题网络社区的链接。 第三方库的安装​ Python的强大，并不是说他的语法有多么多么精妙，而是说Python有很多很多功能强大的第三方库，涉及到各类应用的方方面面，图像处理有pillow、opencv，机器学习有sklearn、tensorflow、keras，科学计算有numpy、scipy等等。 ​ 尽管安装Anaconda的时候已经自带了很多常用的第三方库，但是很多时候这些库并不能完全cover我们的需求，这个时候我们就要自行安装第三方库，这里介绍三种常用的方法。 第一个办法就是上面提到的，在Anaconda Navigator中选择一个环境，然后搜索这个库，选择install即可。 第二个办法是用conda工具，打开一个cmd窗口，然后输入conda install ***（库名），比如安装pandas就是敲入conda install pandas。 第三个办法是使用Python自带的pip工具，也是打开一个cmd窗口，然后输入pip install ***即可。 ​ 对大多数包来说，三种方法都行得通，只有像tensorflow这样的，一般就用第一种方法。 ​ 看了一下课程大纲，要完成这门课要求的话，大家至少得安装以下这些第三方软件包：pillow、opencv-python、pandas、numpy、smtp、email、imaplib、tensorflow、requests、beautifulsoup4、flask、flask_wtf、wtforms。请大家先自行用上述方法安装吧。 Jupyter Notebook​ Jupyter是一个基于web的交互式Python环境。关键词有两个：基于web，交互式。 ​ 基于web是说整个jupyter的界面是在浏览器中实现的，如图。 ​ 交互式是说程序可以局部运行，实时看到执行结果等，是较好的人机体验吧。 ​ jupyter可以在cmd中键入jupyter打开，也可以在Anaconda Navigator的主界面打开。 ​ 小彩蛋：jupyter（Julia+Python+R，三种语言）与jupiter同音，据维基百科说是为了纪念伽利略记录发现木星的卫星的笔记本。 Spyder​ Spyder是一个清爽好用的IDE（集成开发环境），整个默认界面有三部分，和Matlab几乎一模一样……我刚学Python时用的IDE还是PyCharm（后面会介绍、安装），不过由于对Matlab的工作区和命令行念念不忘，实在好用……所以后来还是改用Spyder了。 ​ 默认界面如图，左边一大块代码窗，编辑.py文件（其实也支持其他文件的编辑，就是不能运行罢了），左下角是命令行，熟悉matlab的都懂……就不多说了。然后这两个区域的代码生成的各种变量都保存在工作区，支持双击查看、编辑、保存、删除等操作。 ​ 整体直观方便，如果你熟悉matlab，spyder会是一个很好的IDE选择。 PyCharm简介​ 第二个要安装的软件是PyCharm，也是一个IDE软件。和上述spyder的区别在于这个IDE颜值比较高功能比较丰富。但功能强大带来的一个很直接的问题就是使用起来比较麻烦。 ​ 这是PyCharm的默认界面，确实好看，首先看到的就是一个文件导航、代码窗和打印输出的控制台，没有命令行也没有工作区，看起来好像少了很多功能，但实际上只是PyCharm把他们都藏了起来。 ​ 实际上，PyCharm作为使用最为广泛的Python专用IDE，有很多附加功能，spyder有的工作区、命令行都可以设置（但工作区的实际体验确实不如Spyder）。除此之外，PyCharm的代码编辑功能比Spyder丰富很多，Spyder很大一个槽点就是不支持代码折叠……9012年了还不支持代码折叠也就仅此一家了吧。另外，PyCharm的控制台还集成了Python Console、cmd窗口（terminal）等功能。PyCharm还支持Python第三方包的管理，但在实际使用体验上很多包会安装失败，所以还是用Anaconda来装吧。还有，PyCharm还支持Jupyter交互格式，能打开Jupyter文件并使用……总之，PyCharm功能极为丰富，具体怎么用就留待同学们自己去探索了。 安装​ PyCharm有community和professional两个版本，区别在于前者免费，我们使用前者的功能足矣。 双击运行PyCharm安装包，如果弹出设备更改允许选项，点允许。 弹出PyCharm安装界面，点击next开始安装。 选择安装路径，推荐默认，原因同上。选择完毕点击next开始下一步。 勾选“add launchers dir to the PATH”，将PyCharm路径加入到环境变量PATH中，其余三个随意。 默认名称，点击install开始安装。等待安装完成。 进度条满了之后，点击finish完成安装。可以选择重启更新系统变量。 MySQL简介​ 课程大纲中有涉及到数据库操作的内容，所以我们需要预装一个数据库软件。数据库主要有关系型（SQL）和非关系型（noSQL）两类。P.S. noSQL全称是not only SQL，你说翻译的人当时咋想的给译成了非关系型……然后我们这里使用SQL数据库进行实例介绍，然后具体产品选用了开源免费的MySQL数据库（社区版）。 ​ MySQL作为一种SQL数据库，其特点就是数据按表存储，每行表示一条记录，列名加若干记录组成一张表，若干表又组成一个数据库。我们安装MySQL的实质就是在本地创建一个服务器来存储MySQL数据，以便后续通过一定的方式（命令行/可视化前端）来访问这个服务器以读写其中的数据。 安装 双击运行mysql-installer-community-8.0.16.0.msi，若弹出设备更改选项，点允许。 进入”License Agreement“界面，首先勾选“同意协议”，然后点击next进入下一个页面。 进入“Choosing a Setup Type”界面，选择默认选项Developer Default，然后点击next。 在这个界面会确认安装依赖。有些MySQL产品会依赖一些外部文件/程序才能正常运行，这个时候我们就要先安装被依赖的程序才能继续安装MySQL产品。 这里的话主要是MySQL Sever和MySQL WorkBench两个产品需要依赖Visual C++ Redistributable for Visual Studio 2015，可以点击链接进行下载安装 ，选择其中的x64版本。下载下来之后双击安装即可，然后重启MySQL的安装包。 确认依赖文件安装完成之后点击next进入下一个界面。可能会提示还需要别的依赖文件，但是我们这里暂时用不到，所以直接点确定就行，MySQL会自动取消这些产品的安装。 进入“Installation”界面，确认以下产品会被安装（Server、Workbench、Shell），点击execute，等待所有产品安装完毕。 进入“Product Configuration”界面，默认情况下，会有3个产品需要配置。 点击next开始服务器配置（产品1/3），会进入到一个新的界面。 第一个界面（high availability）：选择MySQL服务器（默认选项），点击next。 第二个界面（type and networking）：协议与网络设置，保持默认配置，直接点next。默认配置如图。 第三个界面（authentication method）：选择使用强密码（默认选项），这个是以后建立MySQL服务器链接的依据，然后点击next。 第四个界面（accounts and roles）：输入你的密码并确认，然后点击next。 第五个界面（windows service）：配置Windows服务，保持默认配置即可，直接点击next。配置如图。 点击execute执行上述配置。等待配置完成，然后点击finish。 回到原来的界面，点击next开始路由配置（产品2/3）。也会进入到一个新界面。 保持默认选项，直接点next完成配置。 回到原来的界面，点击next开始样例设置（产品3/3）。也会进入到一个新界面。 在弹出的界面中输入刚刚设置的密码，然后点击check检测密码是否正确，正确情况下点击next。 在这个界面中点击execute，安装程序会自动在本地的MySQL服务器创建相应的数据库样例。 完成后，点击finish结束样例安装。 至此产品安装就结束了。需要注意的是，此步的安装内容与顺序会因安装的MySQL产品不同而不同。 进入“Installation Complete”界面，安装完成。完成后可能弹出workbench和shell的界面，分别是mysql数据库的图形化界面与命令行界面，暂时不用的话关闭即可。 装完软件之后，可以用MySQL的可视化软件创建一个数据库验证一下。 在Windows开始菜单找到新安装的MySQL Workbench 8.0 CE，并打开。 在界面左侧的MySQL Connections找到Local Instance MySQL80，打开。第一次打开会要求输入密码，输入并点击记住密码即可。 查看已有的数据库：在左侧的导航栏有一个sys数据库（logo像桶），然后里面有tables（logo是3张表）记录了这个数据库里面的所有表，展开之后里面是一张sys_config表，右键Table Inspector可以查看这张表的信息，包括列名、记录行数等信息。 新建一个数据库：界面上方的菜单栏中有一个长得像桶的logo，点击新建一个数据库（输入相关信息后点击apply）。 新建一张数据表：界面左侧的导航栏中展开新建的数据库，在tables处右键选择新建数据表（输入相关信息后点击apply）。 更多操作我们将在后续课程中用python与SQL语句来完成，Workbench的意义还是在于可视化数据库。]]></content>
      <categories>
        <category>生产工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优化基础理论]]></title>
    <url>%2F2019%2F07%2F07%2Foptimizationbase%2F</url>
    <content type="text"><![CDATA[引言​ 小站里面后续很多内容都是围绕着优化展开的，所以第一篇博客自然就要讲一讲优化的基础内容。有两方面目的，一是介绍一些数学基础，省去后续赘述；二是规定一下标准形式，这会影响到后续一些结论的形式，本站均采用Boyd的《Convex Optimization》中的标准形式。 ​ 一般地，一个优化问题可以写为目标函数+约束（进一步区分为等式约束与不等式约束）的格式，本站中规定其标准形式为： \begin{split} &min\ \ &f(x)\\ &s.t. &g(x)\ge0\\ &&h(x)=0 \end{split}​ 再规定上述优化问题的拉格朗日函数为 L(x,\mu,\lambda)=f(x)+\mu ^T g(x)+\lambda ^T h(x)​ 上述形式和一些优化教材中的并不一致，比如陈宝林老师的《最优化》，其乘子定义是上述形式的相反数。之所以在各种形式中选取Boyd书中的这一种，是因为大多数文献中均采用这一格式，且诸多优化求解器如cplex、gurobi中的乘子定义也采用这一格式。 基本概念梯度，雅可比矩阵，与海森矩阵​ 定义向量$x=[x_1,\ x_2,\ \cdots,\ x_n]^T$，标量函数$f(x)$，与向量函数$F(x)=[f_1(x),\ f_2(x),\ \cdots,\ f_m(x)]^T$ 则$f(x)$的梯度定义为 \nabla f(x)=[\frac{\partial f(x)}{\partial x_1},\ \frac{\partial f(x)}{\partial x_2}, \ \cdots,\ \frac{\partial f(x)}{\partial x_n}]^T$f(x)$的海森矩阵定义为 \nabla ^2 f(x) = \begin{bmatrix} \frac{\partial ^2 f(x)}{\partial x_1^2} & \frac{\partial ^2 f(x)}{\partial x_1 \partial x_2} & \cdots & \frac{\partial ^2 f(x)}{\partial x_1 \partial x_n} \\ \frac{\partial ^2 f(x)}{\partial x_2 \partial x_1} & \frac{\partial ^2 f(x)}{\partial x_2 ^2} & \cdots & \frac{\partial ^2 f(x)}{\partial x_2 \partial x_n} \\ \vdots & \vdots & \ddots & \vdots \\ \frac{\partial ^2 f(x)}{\partial x_n \partial x_1} & \frac{\partial ^2 f(x)}{\partial x_n \partial x_2} & \cdots & \frac{\partial ^2 f(x)}{\partial x_n^2} \\ \end{bmatrix}$F(x)$的雅可比矩阵定义为 Jacobi(F)= \begin{bmatrix} \frac{\partial f_1(x)}{\partial x_1} & \frac{\partial f_1(x)}{\partial x_2} & \cdots & \frac{\partial f_1(x)}{\partial x_n} \\ \frac{\partial f_2(x)}{\partial x_1} & \frac{\partial f_2(x)}{\partial x_2} & \cdots & \frac{\partial f_2(x)}{\partial x_n} \\ \vdots & \vdots & \ddots & \vdots \\ \frac{\partial f_m(x)}{\partial x_1} & \frac{\partial f_m(x)}{\partial x_2} & \cdots & \frac{\partial f_m(x)}{\partial x_n} \end{bmatrix}​ 从上述定义中可以看到，$f(x)$的梯度的雅可比矩阵就是其海森矩阵。 凸集​ 记$S\in\mathbb R^n$，若对$\forall x_1,\ x_2\in S, \ \forall \lambda \in [0,1]$有 \lambda x_1 + (1-\lambda)x_2 \in S则称$S$是一个凸集。 ​ 感性来说，在一个集合里面任选两点连起来，如果这条线段被这个集合包围，则为凸集，反之就不是，如图1$^{[1]}$。 图1 左：凸集，右：非凸集 凸函数​ 对于函数$f(x)$，若满足定义域为非空凸集，且对$\forall x_1,\ x_2\in \mathbf {dom} \ f, \ \forall \lambda \in [0,1]$有 f(\lambda x_1+(1-\lambda) x_2) \le \lambda f(x_1)+(1-\lambda)f(x_2)则称$f(x)$是定义域上的凸函数，$-f(x)$是定义域上的凹函数。 ​ 感性来说，一个函数上任意两点连线，这条线段比原函数不低，则为凸函数，反之则不是，如图2$^{[1]}$。 图2 凸函数 ​ 特别地，如果$f(x)$可微，那么可用更方便的一阶条件（要求一阶可微）、二阶条件（要求二阶可微）判断凸函数。 ​ 一阶条件：定义在非空开凸集上的可微函数$f(x)$是凸函数的充要条件是，对$\forall x_1,\ x_2\in \mathbf {dom} f\ $有 f(x_2) \ge f(x_1)+\nabla f(x_1)^T(x_2-x_1)​ 二阶条件：定义在非空开凸集的二次可微函数$f(x)$是凸函数的充要条件是，对$\forall x \in \mathbf {dom} f\ $有$\nabla ^2 f(x)$半 正定。 凸优化问题​ 若一个优化问题是求凸函数在凸集上的极小点，则称为凸优化问题。 ​ 对于引言中所述的优化问题标准形式，若满足$f(x)$是凸函数，$g(x)$是凹函数，$h(x)$是仿射函数，则该优化问题是一个凸优化问题。 ​ 此处要特别注意，优化问题中的约束必须是剔除冗余约束的。举个例子，对于问题 \begin{split} &min\ \ &y\\ &s.t. &y^2-1\ge0\\ &&y\ge0 \end{split}看似$g(y)=y^2-1$的海森矩阵正定，是一个凸函数，故上面这个问题非凸，但实际上从定义出发可推得两个约束构成的可行域是一个凸集，故该问题是一个凸优化问题。之所以产生这样的矛盾是因为上述表达中未剔除冗余约束，把$\{y|y^2-1\ge0\}$改写成$\{y|y\ge1\} \cup \{y|y\le-1\}$，而该集合与另一个约束构成的可行域$\{y|y\ge0\}$的交集为$\{y|y\ge1\}$，即上述问题中$y\le-1$和$y\ge0$均为冗余约束，故原问题等价于 \begin{split} &min\ \ &y\\ &s.t. &y\ge1 \end{split}这显然是一个凸问题，既满足凸问题的原始定义，也符合标准形式判据。 凸优化问题有诸多良好的性质，比如局部最优解就是全局最优解等，通常可以被商业求解器(gurobi、cplex)很好解决，故一个优化问题是不是凸的通常被视为一个问题好不好求解的分水岭。 凸优化问题又可以按照目标函数与约束的函数特点进一步细分为线性规划（LP）、二次规划（QP）、二次约束二次规划（QCQP）、二阶锥规划（SOCP）、以及半正定规划（SDP），后续将会专门出一个blog来介绍这些特殊的凸优化问题。 共轭函数​ 共轭函数又称勒让德变换。记$f(x)$是一个从$\mathbb R^n$到$\mathbb R$的映射，其共轭函数（也是一个从$\mathbb R^n$到$\mathbb R$的映射）定义为 f^*(y)=\mathop{sup}\limits_{x \in \mathbf {dom} \ f} \ (y^Tx - f(x))​ 图3$^{[1]}$是$\mathbb R$空间中一个函数$f(x)$在某个$\hat y$取值处的共轭函数值示意：对一个确定的$\hat y$，以之为斜率作一过原点的直线，记在$\hat x$处有$f’(\hat x)=\hat y$（图中切点），那么$f^*(\hat y)= \hat y ^T \hat x - f(\hat x)$，正是图中$f(x)$切线的截距相反数。 ​ 特别地，当$\hat y=0$时，$f^*(0)$就是$f(x)$下界的相反数。 图3 共轭函数 ​ 共轭函数的一个重要性质是，其是关于$y$的一个仿射函数，是凸的。共轭函数在对偶问题的表示上有重要作用，尤其是线性约束的优化问题（$y$视为对偶变量）。 最优性条件​ 对于一个优化问题，若要找到其最优解，首先就要明确最优解有什么性质，满足什么条件，然后才能够据此去推导求解的算法。最优解满足的条件（必要、充分、充要）称为最优性条件。 ​ 本节仅介绍各种问题的最优性条件，其中的推导与证明可在[1]、[2]中找到。 ​ 在邻域内目标函数值最小的解称为局部最优解（极小点），在整个定义域内目标函数值最小的解称为全局最优解（极小点）。 无约束问题的最优性条件​ 对于可行域是全空间的无约束优化问题 min\ \ f(x)一阶必要条件​ $f(x)$在$\hat x$处可微，若$\hat x$是局部极小点，则$\nabla f(\hat x)=0$。 ​ 这是一个必要条件而非充分条件。一般地，满足$\nabla f(x)=0$的点称为$f(x)$的驻点，如果驻点邻域内的函数值均比驻点函数值大，则该驻点称为极小点；如果驻点领域内函数值均比驻点函数值小，则该驻点称为极大点；两者均不满足则称为鞍点，如图4。 图4 驻点：极小点、极大点与驻点 二阶必要条件​ $f(x)$在$\hat x$处二次可微，若$\hat x$是局部极小点，则$\nabla f(\hat x)=0$，且$\nabla ^2 f(\hat x)$半正定。 ​ 相比一阶必要条件，二阶必要条件多的“海森矩阵“就是用来判断驻点类型的。一般地，对于极大点，海森矩阵半负定；对于极小点，海森矩阵半正定；对于鞍点，海森矩阵不定。 二阶充分条件​ $f(x)$在$\hat x$处二次可微，若$\nabla f(\hat x)=0$，且$\nabla ^2 f(\hat x)$正定，则$\hat x$是局部极小点。 充要条件​ $f(x)$是可微凸函数，则$\hat x$是局部极小点（也是全局最优解）的充要条件是$\nabla f(\hat x)=0$。 ​ 嗯，凸优化问题的良好求解性质可见一斑。 有约束问题的最优性条件​ 对于有约束优化问题（这里不妨都假设$f(x),\ g(x),\ h(x)$均可微） \begin{split} &min\ \ &f(x)\\ &s.t. &g(x)\ge0\\ &&h(x)=0 \end{split}​ 定义广义拉格朗日函数 L(x,\mu,\lambda)=f(x)+\mu ^T g(x)+\lambda ^T h(x)其中$\mu, \ \lambda$称为约束的拉格朗日乘子，其物理意义是约束的右手项（式中为0的那个常数项）变动一个单位对目标函数最优值的影响。 ​ 乘子在很多领域都有直接的应用，在经济学中资源约束的乘子又称为资源的影子价格，在电力市场中有功平衡约束的乘子又称为节点电价。 一阶必要条件（KKT条件）​ 对于上述优化问题，如果$\hat x$是其局部最优解，且$\nabla g(\hat x), \ \nabla h(\hat x)$线性无关，那么必然存在$\hat \mu, \ \hat \lambda$使得 \left \{ \begin{array} \\ & \nabla_xL(\hat x,\ \hat \mu,\ \hat \lambda)=0 &(1) \\ & g(\hat x)\ge0 &(2) \\ & h(\hat x)=0 &(3) \\ & \hat \mu _i g_i(\hat x)=0 &(4) \\ & \hat \mu \ge 0 &(5) \\ \end{array} \right.​ 上式又称为KKT条件，其中： ​ （1）式可以直观地理解为无约束优化问题一阶必要条件的推广，即，将有约束问题的约束通过拉格朗日松弛罚到目标函数中，转成一个无约束问题，再使用无约束优化的一阶必要条件，就是（1）式。 ​ （2）式和（3）式是原问题约束，保证了解的可行性。 ​ （4）式称为互补松弛约束，即每个不等式约束的函数值和其乘子之积择一非零，下标$i$表示约束向量和乘子向量中的各个分量。写成矩阵形式即两个向量正交：$\hat \mu \bot g(\hat x)$。互补松弛约束的物理意义是说，对于每一个不起作用约束（那些函数值大于0而不是等于0的约束）其乘子一定为零。套用影子价格的物理概念，这是很直观的一件事情：如果某项资源在达到最优解时仍有剩余，那么再增加或减少这项资源一个$\epsilon$（无穷小量），并不会引起最优利润的改变，所以影子价格为0，也就是乘子为0。 ​ （5）式是推导过程中的中间条件（用于Gordan定理的应用）。 一阶充分条件​ 特别地，如果该优化问题是一个凸优化问题，那么KKT条件也是“$\hat x$是局部（或全局）最优解”的充分条件。 二阶条件​ 无约束优化的二阶条件也可以推广到有约束优化，即从目标函数的海森矩阵推广到拉格朗日函数的海森矩阵，但会增加一些复杂的规格约束。实际使用中感觉一阶条件更为常用，二阶条件使用较少，在Boyd的书中我也没找到相关论述，感兴趣的同学可以参考陈宝林老师的《最优化》$^{[2]}$中7.2.5节。 对偶问题​ 对偶问题有着强烈的物理意义，在很多算法中都有巧妙的应用，所以在这里也介绍经常用到的一些基本概念。 原问题与对偶问题​ 对于优化问题（称为原问题） \begin{split} & \mathop{min} \limits_x \ &f(x) \\ &s.t. &g(x)\ge0 \\ &&h(x)=0 \\ &&x \in D \end{split}其中集合$D$称为原变量$x$的集约束。集约束可以任意选取，比如选为$\mathbb R ^n$，在比如把$g(x),\ h(x)$全部放进来，均不影响最终求得的对偶问题的一致性，但是会影响计算对偶问题目标函数（又称为拉格朗日对偶函数）的工作量。 ​ 上述原问题对应的对偶问题为 \begin{split} &\mathop{max}\limits_{\mu,\ \lambda} \ &\mathop{inf}\limits_{x \in D} \ L(x,\mu, \lambda) \\ &s.t. &\mu \ge0 \\ \end{split}​ 对偶问题具有互逆性，即对偶问题的对偶问题是原问题。 对偶定理弱对偶定理​ 原问题目标函数值总是大于等于对偶问题目标函数值，即 f(x)\ge\mathop{inf}\limits_{x \in D} \ L(x,\mu, \lambda)\ \ \ \ \ \forall x,\ \mu,\ \lambda​ 原问题目标函数下界与对偶问题目标函数上界之差称为对偶间隙，即$\mathop{inf}\limits_{x}\ f(x)-\mathop{sup}\limits_{\mu,\ \lambda}\ \mathop{inf}\limits_{x \in D} \ L(x,\mu, \lambda)$。 强对偶定理​ 若原问题是一个凸优化问题，且满足slater约束规格，则原问题目标函数下界与对偶问题目标函数上界之差为0，即不存在对偶间隙。 ​ 可见凸优化问题的又一良好求解性质，此时可以通过求对偶问题上界来求原问题最小值，这是在很多算法中经常使用的手段。 鞍点定理 若$\hat x, \ \hat \mu,\ \hat \lambda$满足 L(\hat x,\ \mu,\ \lambda)\le L(\hat x, \ \hat \mu, \ \hat\lambda)\le L(x, \ \hat \mu, \ \hat\lambda)​ 则称$(\hat x, \ \hat \mu, \ \hat\lambda)$是拉格朗日函数的鞍点。 若$(\hat x, \ \hat \mu, \ \hat\lambda)$是拉格朗日函数的鞍点，则$\hat x$和$(\hat \mu,\ \hat \lambda)$分别是原问题和对偶问题的最优解。 若原问题是凸优化问题，且满足slater约束规格，且存在最优解$\hat x$，那么存在$\hat \mu (&gt;0), \ \hat \lambda$使得$(\hat x, \ \hat \mu, \ \hat\lambda)$是拉格朗日函数的鞍点。 优化问题的求解算法​ 在分析了最优性条件之后，就是要利用这些性质去推导求解优化问题的算法。 ​ 按照求解算法是否利用目标函数的导数信息，优化问题的求解算法可以分为使用导数的优化方法和不使用导数的直接方法两大类。按照求解的优化问题有没有约束，优化问题的求解算法又可以分为无约束问题的优化方法和有约束问题的优化方法。 ​ 这一部分内容比较多，后续将会专门开一个blog来介绍各种优化算法的原理推导、工作特性以及代码实现等。 参考资料[1] Boyd S, Vandenberghe L. Convex optimization[M]. Cambridge university press, 2004. [2] 陈宝林，最优化理论与算法，清华大学出版社，2005]]></content>
      <categories>
        <category>优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客编辑与发布]]></title>
    <url>%2F2019%2F07%2F07%2Fblog-edit-deploy%2F</url>
    <content type="text"><![CDATA[markdown规则——怎么写blog标题1个# 到 6个# 分别表示一级标题（large）到六级标题（small)。#号与文字之间留一空 列表无序列表前面加* 1 (* 1) 2 (* 2) 有序列表前面加数字 1 (1. 1) 2 (2. 2) 引用 文字前面加&gt; (&gt; 123) 插入图片 上一行代码为 ! [图片名] (图片地址/链接) 超链接这是GitHub的网站链接。 上一行代码为 这是[GitHub] (http://github.com)的网站链接 粗体与斜体这几个字是粗体，用两个星号包围 这几个字是斜体，用一个星号包围 上一行代码为 **……** *……* 用’\\’进行转义 代码框12import numpy as npimport tensorflow as tf 格式为``` codes ``` 更多规则公式、脚注、删除线、上下标、任务列表、高亮等，点击链接 博客推送规则——怎么传blog 前序工作：github申请一个page，本地安装git、nodes、hexo等，完成个性化设置……详情点击 常用指令： hexo clean：清除部署网站的缓存 hexo g：generate，在本地生成静态网页文件 hexo d：deploy，将本地静态文件部署到github hexo s：sever，将本地静态文件部署到本地端口（localhost:4000） hexo new blogname：新建一个名为blogname的博客 hexo new page pagename：新建一个名为pagename的子网页 blog推送 在hexo安装文件夹处打开git窗口（git bash here）。 hexo命令新建一个博客：hexo new newblog，然后会在hexo文件夹下的/source/_posts文件夹里面生成相应名字的md文件（newblog.md）。 在这个md文件中写入博客内容（markdown格式）。 git窗口中依次输入指令hexo clean清除缓存，输入指令hexo g在本地生成静态文件，输入指令hexo d部署到github中。 完成blog发布。]]></content>
      <categories>
        <category>生产工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
